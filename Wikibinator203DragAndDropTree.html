<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<script src="Wikibinator203VM.js" charset="UTF-8"></script>
<script>
//TODO move window out of that lambda then... const Wikibinator203DragAndDropTreeUI = (()=>{

//This script is under the Wikibinator203 license.

//drag and drop tree UI for viewing and calling Wikibinator203 fns/lambdas...

const U = Wikibinator203; //the universal function
if(U(U(U))(U) !== U(U(U))(U)) throw 'Lambda equality is broken';
const vm = Wikibinator203.n.vm; //anyWikibinator203Lambda.n is its vm.Node instance, wrapped in a lambda by vm.lambdize(node)

const loadOpsByName = true;
console.log('loadOpsByName='+loadOpsByName);

//let S = vm.ops.S;
//let T = vm.ops.T;
//let F = vm.ops.F;
//let Pair = vm.ops.Pair;
if(!vm) throw 'No vm';
if(loadOpsByName) for(let op in vm.ops){
	if(window[op]) throw 'Already have var window.'+op;
	window[op] = vm.ops[op];
	console.log('Created var for opcode as lambda: window.'+op);
}

/*const firstCode =
`[
I#(F U)
Sqr#{(T *) I I}
Hypot#(
	λ [x y]
	[this is [a comment] with a function Sqr in it]
	{
		(T Sqrt)
		{
			(T +)
			{(T Sqr) (P x)}
			{(T Sqr) (P y)}
		}
	}
)
the hypotenuse of a right triangle of sides 6 and 8 is (Hypot 6 8) and that func is Hypot and as a 1 param func is (Hypot 6)
]`;
*/
const firstCode = '[I#(F U) Sqr#{(T *) I I}]';

const exampleFnToDisplay = vm.eval(firstCode); //a Wikibinator203 fn/lambda (which is a js lambda)


//START Splat.dobs keys:

/*
//The dom object that the other splat dobs are childs of. This is normally a div.
const SELF = 'self';

//Example: Display '[' or '(' at top left corner.
//This might just be a html label.
const PREFIX = 'prefix';

//drop (or during drag displays where would drop) left/above/before the left of 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPLEFT = 'dropleft';

//left splat child of a splat.
//This is normally a div.
const LEFT = 'left';

//drop (or during drag displays where would drop) between 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPMID = 'dropmid';

//where to display a canvas, text, pdf file, jpg file, or other literal value, but only do this if childs are NOT displayed
//(a necessary but not sufficient condition),
//check split for should it be displayed and caching of the Uint8Array of canvas bytes etc.
//This is normally a div or maybe a canvas, or a div with a canvas in it, etc.
const LITERAL = 'literal';

//right splat child of a splat.
//This is normally a div.
const RIGHT = 'right';

//drop (or during drag displays where would drop) right/below/after the right of 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPRIGHT = 'dropright';

//Example: Display ']#NameXYZ' or ')#NameXYZ' or ']' or ')' at bottom left corner or on right if 1 line.
//This might just be a html label.
const SUFFIX = 'suffix';
*/

//END Splat.dobs keys.


//TODO "SOLUTION: Fixing this by dividing Split into 2 classes: Split (immutable, up from any closed leafs),
//and Splat (mutable, has dom nodes). Split.prototype.displayIn(Splat) fills in those dom nodes,
//and removes some dom nodes if they're no longer used.
//Split can share branches and is a forest (like fn). Split might be made of fns later (TODO?).
//Splat is a tree and cant share branches.
//A split is dragged from any part of Splat to any part of Splat."
//
var Splat = function(parentSplatOrNull, splate){

	this.splate = splate; //doesnt include splates for leftSplat or rightSplat. Its local to this Splat.
	//this.split = null; //TODO
	
	//map of string to dob (dom object).
	//TODO dobs for the 2 childs, prefix and suffix, etc.
	//TODO also include dobs for "include extra divs, normally empty, in every Splat, in every
	//possible place in that splat it could be dropped, including hidden splats".
	this.dobs = {};
	
	this.parentSplat = parentSplatOrNull || null; //null if this is a top Splat (probably just these 2: rootSplat and dragSplat)
	this.leftSplat = null; //null if not viewing left child
	this.rightSplat = null; //null if not viewing right child
};

//lazy create left splat
Splat.prototype.L = function(){
	if(!this.leftSplat){
		//let leftSplate = defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable. Also, this shouldnt be defaultSplate.
		let leftSplate = this.splate.simpleLeftSplate();
		this.leftSplat = new Splat(this, leftSplate);
		this.leftSplat.parentSplat = this;
	}
	return this.leftSplat;
};

//lazy create left splat
Splat.prototype.R = function(){
	if(!this.rightSplat){
		//let rightSplate = defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable. Also, this shouldnt be defaultSplate.
		let rightSplate = this.splate.simpleRightSplate();
		this.rightSplat = new Splat(this, rightSplate);
		this.rightSplat.parentSplat = this;
	}
	return this.rightSplat;
};

//new dob/domObject
var Nob = (tag,optionalParent,optionalInnerHtml)=>{
	let dob = document.createElement(tag);
	if(optionalInnerHtml) dob.innerHTML = optionalInnerHtml;
	if(optionalParent) optionalParent.appendChild(dob);
	return dob;
};

Splat.prototype.parentDob = function(){
	if(this.parentSplat){
		if(!this.parentSplat.dobs.self){
			console.log('child splat creating dobs in parent. FIXME? why didnt parent do it already?');
			this.parentSplat.createDobsIfNotExist();
		}
		return this.parentSplat.dobs.self;
	}else{
		if(!rootDob) throw 'No rootDob';
		return rootDob;
	}
};

//Keys in splat.dobs, except 'self' which contains all those.
var childDobNames = 'prefix dropleft left dropmid literal right dropright suffix'.split(' ');

var sytyToPushChar_ = {
	'IC0': '[',
	'IC+': '[',
	'C': '(',
	'S0': '(',
};

var sytyToPushChar = syty=>(sytyToPushChar_[syty] || 'FIXME_WHAT_PUSH_CHAR_FOR_SYTY='+syty);

var sytyToPopChar_ = {
	'IC0': ']',
	'IC+': ']',
	'C': ')',
	'S0': ')',
};

var sytyToPopChar = syty=>(sytyToPopChar_[syty] || 'FIXME_WHAT_POP_CHAR_FOR_SYTY='+syty);

Splat.prototype.createDobsIfNotExist = function(){
	if(!this.dobs.self){
		console.log('splat creating this.dobs.self, which contains the other dobs of this splat');
		this.dobs.self = Nob('div', this.parentDob());
	}
	for(let dobName of childDobNames){
		if(!this.dobs[dobName]){
			//let text = 'x_syty='+this.splate.syty;
			let text = null;
			let dob = Nob('div', this.dobs.self, text);
			dob.classList.add('wikib_'+dobName);
			this.dobs[dobName] = dob;
		}
	}
};

Splat.prototype.displayIn = function(dob){
	console.log('Splat displayIn '+dob);
	if(this.dobs.self != dob){
		console.log('Splat replacing its dobs');
		dob.innerHTML = '';
		for(let dobName in this.dobs){
			this.dobs[dobName].remove(); //remove from dom tree
			delete this.dobs[dobName];
		}
		this.dobs.self = dob;
		this.createDobsIfNotExist();
		if(this.splate.isDisplayPushAndPopChars){
			let prefix = sytyToPushChar(this.splate.syty);
			let suffix = sytyToPopChar(this.splate.syty);
			if(this.splate.isDisplayName){
				suffix += '#TODONAMEHERE';
			}
			this.dobs.prefix.innerHTML = prefix;
			this.dobs.suffix.innerHTML = suffix;
		}
	}
	if(this.splate.isOpen){
		//if(this.leftSplat){
			console.log('Splat displaying left child');
			//this.leftSplat.displayIn(this.dobs.left);
			this.L().displayIn(this.dobs.left);
		//}
		//if(this.rightSplat){
			console.log('Splat displaying right child');
			//this.rightSplat.displayIn(this.dobs.right);
			this.R().displayIn(this.dobs.right);
		//}
	}
};



//a split is a view of a fn/lambda and its 2 child fn/lambdas, with each child being open or closed.
//a split is immutable. If its a view of U (leaf aka the universal combinator) or of a literal then childs wont be displayed.
//
//FIXME make it a fractal, not a tree.
//Making a drag-and-drop tree UI for #wikibinator. Each branch is a javascript lambda (useable on browser console
//or by drag and drop). But its not actually a tree. Its a fractal. Without exception, every branch has 2 child branches,
//that when called on eachother return the parent.
//
//The first n fns in a [] {} () <> can be viewed as closed, and just {} call that closed localId on those after the first n,
//but those would be different Splits.
/*
var Split = function(fn, leftOpen, rightOpen, literalOpen){
	this.fn = fn;
	//There can be multiple Splits for same fn since they can view it diff ways.
	this.leftSplit = null; //TODO a Split for L(this.fn)
	this.rightSplit = null; //TODO a Split for R(this.fn).
	this.leftOpen = leftOpen;
	this.rightOpen = rightOpen;
	this.literalOpen = literalOpen;
	
	//map of string to dob (dom object)
	this.dobs = {};
	
	FIXME should it be selfOpen instead of leftOpen and rightOpen?
	
	FIXME should Split know about height and width sizes recursively? Or leave that to Branch?
	
	TODO should Split have isOneLine var?
	
	TODO use vm.ParseTree to get syty (syntax type) of this.fn.
	
	TODO when start dragging with mouse, it should grab a Split, not a Branch?
};*/

//Splate is local SPLat and SPLit stATE (Split is immutable so has only 1) not including its childs.
//Renaming ViewType to Splate.
//
//(todo use as immutable) all the options for a splat and (if open) its 2 splat childs,
//including bit for is this splat open/closed, display as childs vs literal, css-like options, etc.
//A fn can be part of an immutable splate cuz (other than some internal optimizations)
//its an immutable (lazy-deduped, multi fn objects of same shape but different 128 bit localId) forest shape
//where all paths lead to U/Wikibinator203/TheUniversalCombinator.
var Splate = function(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars){

	if(!vm.isLambda(fn)) throw 'Not a Wikibinator203 lambda: '+fn;
	this.fn = fn;

	if(!syty) throw 'No syty';
	//of what vm.ParseTree would compute syty of a fn. syty is a small string,
	//a syntax type (like in an AST node in parsing, but in the prototype VM thats vm.View)
	//This is instead of split.dity, but some values of dity (such as 'literal')
	//are not syty's so need more vars for them in ViewType.
	this.syty = syty;
	
	this.isOpen = !!isOpen;
	
	this.isOneLine = !!isOneLine;
	
	//TODO can (but careful of content types that can create infinite loops
	//crashing the browser tab, and of types that would be tried to save-as/download (popup)
	//executable file types, cuz fns can in theory make all possible file types and offer for download,
	//all from browser memory without files first existing on a drive)
	//...can display various file types in an iframe andOr img src= etc in the splat tree,
	//but put some checkboxes andOr warnings about downloading such files at time they're offered for download.
	//Such downloads are outside the sandbox as soon as they're named something other than .wikib
	//or .wikibinator203 or something like that (TODO choose file extensions .what to store lambdas).
	this.isLiteral = !!isLiteral;
	
	//Should the prefix dob display something like ]#NameXYZ or 3.141592653589793#Pi64 ?
	//#Names start with A-Z (1 char) but other than that can have any unicode symbols except whitespace []{}()<> etc.
	//Most strings other than that are themself as a stringLiteral such as hello in [hello world].
	//If it starts with 0-9 etc its a double literal.
	//TODO move some comments to isLiteral.
	//Most fns never have a name. Names are local to a VM and dont affect 256/512 bit globalIds or 128 bit localIds.
	//TODO name can be generated (choose random string starting with 1 char A-Z).
	//Name of a fn is different than the "var names" in loops, if/else, fork/kernel n ways, etc.
	//Those "var names" are normally string literals such as x y z こんにちは世界 etc.
	//Technically any fn can be such a "var name", even if its 1 of the exact values of pi (fn of digit index to digit),
	//but it seems more useful for names to be small strings.
	this.isDisplayName = !!isDisplayName;
	
	this.isDisplayPushAndPopChars = !!isDisplayPushAndPopChars;
	
};

//FIXME you shouldnt need to copy a Splate since it should be used as immutable,
//but in this early prototype of the UI I'm modifying vars in it cuz forkEditing it isnt working yet.
Splate.prototype.copy = function(){
	return new Splate(this.fn, this.syty, this.isOpen, this.isOneLine, this.isLiteral, this.isDisplayName, this.isDisplayPushAndPopChars);
};

//makes a Splate of left child of fn, with everything open except if its U then closed.
//Normally you'll want to create a custom Splate, for custom ways to display it, but this is just to get started fast.
Splate.prototype.simpleLeftSplate = function(){
	if(this.fn.n.isLeaf()){
		return defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable.
	}else{
		let fn = this.fn.n.L();
		let syty = fnToSyty(fn);
		let isOpen = true;
		let isOneLine = true;
		let isLiteral = false;
		let isDisplayName = false;
		let isDisplayPushAndPopChars = true;
		return new Splate(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars);
	}
};

Splate.prototype.simpleRightSplate = function(){
	if(this.fn.n.isLeaf()){
		return defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable.
	}else{
		let fn = this.fn.n.R();
		let syty = fnToSyty(fn);
		let isOpen = true;
		let isOneLine = true;
		let isLiteral = false;
		let isDisplayName = false;
		let isDisplayPushAndPopChars = true;
		return new Splate(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars);
	}
};

//this is for U.
var defaultSplate = new Splate(U, 'C', false, true, false, true, false);


//all 3 params are optional
//TODO write new description now that theres both Split and Splat (old Split code was divided into that).
//var Split = function(fn, leftSplit, rightSplit, displayType, isOneLine){
//Renaming ViewType to Splate.
var Split = function(splate, leftSplit, rightSplit){

	this.splate = splate ? splate : defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable.
	
	//There can be 0 or more parents of Split cuz its an immutable forest, unlike Splaat which is a mutable tree.
	//Split therefore only knows its childs, down to whichever are viewed as closed (by #Name or localId or globalId).
	//A Split is itself open or closed
	this.leftSplit = leftSplit || null;
	this.rightSplit = rightSplit || null;
	
	
	/*
	//TODO How this Split is displayed depends on this.parentSplit.dity,
	//like parentSyty is used in in vm.ParseTree, vm.eval, etc.
	//fns/lambdas have no parent, but Splits do. Splits are a tree and not a forest. fns are both.
	this.parentSplit = parentSplit;
	this.leftSplit = leftSplit;
	this.rightSplit = rightSplit; throw 'TODO';
	*/
	
	
	
	/*FIXME how can Split be immutable and tell all 3 at once: parent, left, and right splits?
		And is there lazyEval of creating left and right Split childs when observed,
			cuz without that how would you look deeper into a very big forest of fns viewed by Splits?
	...
	I basically want forkEditable maps of fn to displayParams, except the fns can be duplicated,
	so maybe key is fn_with_arbitraryNumber?
	No, the map should use a fn and l l l r l r r l paths in it as key.
	I can make forkEditable treemaps, but the problem seems to be I want to be able to expand it on both ends,
	the parent direction and the childs direction.
	Need to copy these trees of Split and keep which parts are open/closed in the copy,
	make variants, mix them in various combos, etc.
	
	Here's the design (closer to it, todo keep fixing this...):
	A leaf Split is a closed view of a fn. A split can be made of any 2 Splits or be a leaf.
	Opening such a closed Split requires forkEdit all the way up the immutable tree of Split,
	which requires updating display of everything changed during that,
	but FIXME... FIXME... A dob cant have 2 parents, so either need to use immutable graphics,
	such as tree of y10x10rgb12 voxels with offset per branch, or make new dobs in the whole tree with each change.
	
	Pics as canvas bytes need to be cached somehow.
	Maybe fn.n.blob is a good enough cache, being the canvas bytes directly in some cases.
	I dont want to replace text on screen after every open/close, cuz it might interfere with which text is selected,
	but on the other hand you wont be actively using the text selection when you're opening/closing something.
	
	SOLUTION: Fixing this by dividing Split into 2 classes: Split (immutable, up from any closed leafs),
	and Splat (mutable, has dom nodes). Split.prototype.displayIn(Splat) fills in those dom nodes,
	and removes some dom nodes if they're no longer used.
	Split can share branches and is a forest (like fn). Split might be made of fns later (TODO?).
	Splat is a tree and cant share branches.
	A split is dragged from any part of Splat to any part of Splat.
	*/
	
	
	
	//'literal', 'localId', 'localName', 'hidden', or syty of fn, and maybe a few other possible values.
	//TODO choose shorter names for those such as 'lit' instead of literal.
	//This chooses if its displayed as open or closed, and if open then as canvas bytes, text, [], {}, (), <>, etc.
	//vm.ParseTree can give syty of a fn.
	////this.dity = displayType;
	
	////this.isOneLine = isOneLine;
	
	//FIXME where do height and width in pixels go for canvas bytes literal?
	
	//Moving this to Splat, so Split can be immutable forest, and Splat can be mutable tree with dom nodes.
	//map of string to dob (dom object)
	//this.dobs = {};
};

/*
//a leaf split is closed. Otherwise, since fn is a fractal (every fn has 2 child fns that when called
//on eachother return that parent fn), it will expand forever into childs.
Split.prototype.isLeaf = function(){
	throw 'TODO get from this.dity';
};

Split.prototype.isDisplayPrefixAndSuffix = function(){
	throw 'TODO';
};

//Example: '['. Prefix and suffix are not always used, depending if parent is doing the prefix and suffix.
Split.prototype.prefix = function(){
	throw 'TODO';
};

//Example: ']#NameXYZ'. Prefix and suffix are not always used, depending if parent is doing the prefix and suffix.
Split.prototype.suffix = function(){
	throw 'TODO';
};
*/

//FIXME splits must not contain dobs, instead dobs are in splats.
//param is normally a div.
/*Split.prototype.displayIn = function(dob){
	//this.dity is a string. why is this code here? this.dity.dob = dob;
	dob.innerHTML = '';
	throw 'TODO';
};*/
Split.prototype.displayIn = function(splat){
	throw 'TODO';
};

var newSplateForFnAsRoot = function(fn){
	let syty = fnToSyty(fn);
	//FIXME should depend on parent syty, or parent of parent of parent... How did VM do it? Check vm.View.prototype.syty.
	let isDisplayPushAndPopChars = true;
	return new Splate(fn, syty, true, false, false, false, isDisplayPushAndPopChars); //FIXME which true/falses?
};

var fnToView = fn=>vm.getViewer().view(fn);

//creates sytys all the way down, on L and R childs of fn, but (FIXME verify) not past blob wrappers,
//and FIXME it should depend on splate.isOpen etc and maybe that of its childs (if parent isOpen but not 1 or both of its childs).
var fnToSyty = fn=>fnToView(fn).syty();

/*
//draggable tree node, view of a fn/lambda as a var size list or literal. Literals can be text, sounds, canvas bytes, etc.
var Branch = function(split){

	FIXME, should Branch be immutable (other than maybe some dob/domObject optimizations)?
	Yes, do that. But optimize for reusing canvas(es) for low lag cuz changing dom tree maybe is not as fast as video frames in canvas.
	Might cause a problem with renaming #Names after theyre displayed.
	Maybe Names and literals(like a pic displayed in canvas, changing every 1/60 second for interactive video) should
	be in a separate js type than Branch, so they can update on their own, without changing size, and without interfering
	with the Branch objects?
	Should each Branch take a height and width in its constructor, maybe in units of monospaced chars?
		That could be a problem for magnifying/shrinking big names to fit in the same space.
	Imagine dragging a Branch (a rectangle on screen) onto another Branch to call it, in {} [] () or <>.
		Just making the tree causes the call.
	Fixing some of that using the Split class which is an immutable view of 
		
	
	
	//this.fn = fn;
	this.split = split;
	
	//or if its displayed as just a Name# (defined somewhere else) then no prefix or suffix.
	this.prefix = ''; //Examples: [ { ( <
	this.suffix = ''; //Examples: ] } ) >
	
	//dom object, maybe a div. div may contain canvas andOr child Branchs.
	//Contains childsDob and maybe other stuff (such as displaying this.prefix and this.suffix left of it tabbed over).
	this.dob = null;
	
	this.prefixDob = null;
	
	//TODO move Name# to end instead of start, so its (...)#Name, cuz theres more room on the closing paren/etc, often in its own line.
	//and cuz you cant use #Name before its (...) is defined, so you cant create cycles in the lambda forest.
	this.nameDob = null;
	
	//may be a canvas or text or 0x45f9 cbt or 2.34 number or localId or globalId etc.
	//This must be used if !this.treeOpen
	this.literalDob = null;
	
	//inside this.dob, near this.prefix. controlsDob has a checkbox to change this.treeOpen
	//and maybe other controls to change how things are displayed.
	//TODO where is this.fn dragged from?
	this.controlsDob = null;
	
	//tabbed over 1 tab to the right of this.prefix, and this.suffix is down right from childsDob and is on its own line,
	//or if its all on 1 line then childsDob is between this.prefix on its left and this.suffix on its right with no tabs.
	//childsDob contains all Branchs in this.childs, if this.treeOpen, else is empty/hidden/etc.
	this.childsDob = null;
	
	this.suffixDob = null;
	
	FIXME should there be Branch for every fn or just one per var size list?
	
	//child Branchs. They may or may not be displayed.
	this.childs = [];
	
	//If false, this is displayed as this.fn.n.locid() (string form of 128 bit local id). If true, childs are displayed.
	this.treeOpen = true;
	
	//If childs fit on 1 line, then set this to true. Starts false in case they dont,
	//since fn hasnt been tostringed to know how big its code is, which parts are displayed etc.
	//If one line, then this.prefix is leftmost and this.suffix is rightmost (around other contents) in same line.
	this.isOneLine = false;
};

Branch.prototype.display = function(){
	throw 'TODO';
};
*/


//display rootSplat in rootDob, the main rectangle that Wikibinator203 fns/lambdas are viewed and drag-and-drop to call in.
var rootSplat = new Splat(null, newSplateForFnAsRoot(exampleFnToDisplay));
//rootSplat.split = newSplitForFn(exampleFnToDisplay);
var rootDob = null; //TODO


/*TODO how will Split and Splat do the graphics of dragging, during the drag?
I want it to show either a small icon or a whole splat, during the drag.
Maybe I should include extra divs, normally empty, in every Splat, in every
possible place in that splat it could be dropped (UPDATE: those are dropleft, dropmid, and dropright),
including hidden splats?
Or maybe there should be a second rootSplat-like var called dragSplat?
Do both, and keep moving dragDob, which dragSplat is displayed in,
to these drop target dobs in the splats.
Once dropped, it forkEdits rootSplat.split and displays that in rootSplat,
and maybe there will be an undo button and history for going way back
andOr some quicksave and quickload buttons etc.
Any split should display the same even if its loaded again,
and maybe later I'll make it be made completely of fns instead of a split just wrapping a fn.
*/
var dragSplat = null; //TODO when dragging
var dragDob = null; //dragSplat.displayIn(dragDob). rootSplat.displayIn(rootDob).

var rootDisplay = isForce=>{
	console.log('rootDisplay');
	if(isForce || !rootDob) rootDob = Dob('rootDob');
	rootSplat.displayIn(rootDob); //FIXME is this compatible with split.displayIn(splat)?
};

var Dob = id=>document.getElementById(id);

window.onload = ()=>{
	rootDisplay();
};


/*return {
	U: U,
	vm: vm,
	Split: Split,
	loadOpsByName: loadOpsByName,
};*/
//TODO move window out of that lambda then... })();
</script>
<script>
	
</script>
</head><body>
	drag and drop tree UI for viewing and calling Wikibinator203 fns/lambdas...
	<br><br>
	Doesnt work yet. Use Wikibinator203DirectedGraphUI.html instead.
	<br><br>
	<div id=rootDob>(rootDob)</div>
	
</body></html>
